---
layout: post
title: Advanced ExecutorService tutorial
categories:
- Development
tags:
- Java
- Concurrency
comments: []
---
<p>A friend of mine brought my attention to the fact that many tutorial about Java concurrent programming introduce the Executor Interfaces and its descendants but fails to show&nbsp;its usage in a real-life scenario. This article is my attempt to present the reader with a complex case where the production of the tasks to run, their execution and the consumption of the results constitute a dynamic system. It is assumed the reader is already familiar with Java <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html">Thread</a>, <a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Runnable.html">Runnable</a>,&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Future.html">Future</a> and&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html">ExecutorService</a>.<!--more--></p>
<h2>Base&nbsp;entities</h2>
<p>At its core, the system is working on three classes of objects:</p>
<ul>
<li><strong>Task</strong>: the algorithm that is to be parallelized; it can be a mathematical computation or a routine with blocking calls (disk or network i/o, database queries, etc.)</li>
<li><strong>TaskParameter</strong>: the input data fed to the Task; as it can become a complex structure in real-life, having a dedicated class keep things clean</li>
<li><strong>TaskResult</strong>: the output produced by the Task; just like TaskParameter, having a dedicated class contributes to code maintainability</li>
</ul>
<p>The algorithm constituting the Task can require a large amount of memory. Thus, separating the TaskResult from the Task optimizes memory usage: as soon as a task is completed, the corresponding Task object can be deleted and its memory reclaimed by the GC. Only the TaskResult is kept in memory.</p>
<h2>Workflow</h2>
<p>The overall workflow has four steps:</p>
<ol>
<li>Craft a TaskParameter</li>
<li>Create a Task associated to that TaskParameter</li>
<li>Run the Task</li>
<li>Do something with the TaskResult</li>
</ol>
<p>In simple scenarios, the TaskParameters and the Tasks are created at the launch of the program, then the Tasks would be concurrently executed in threads. But in a real-life scenarios, the creation of TaskParameters and Tasks is concurrent with the execution of Tasks. Moreover, in real-life, the TaskResults are actually used somehow (eg. written to disk or written to a socket).</p>
<h2>Entities</h2>
<p>A&nbsp;complex system would be composed of:</p>
<ul>
<li>A <strong>TaskProducer</strong>: create TaskParameter and Task.</li>
<li>A <strong>TaskQueue</strong>, where the TaskProducer put tasks ready for execution (sometimes called CompletionQueue in the doc)</li>
<li>An <strong>Executor</strong>: retrieve Task from the queue and execute them concurrently</li>
<li>A <strong>ResultQueue</strong></li>
<li>A <strong>ResultConsumer</strong>: retrieve the TaskResult from the ResultQueue and do something with it.</li>
</ul>
<p>As one can imagine, TaskProducer and ResultConsumer are specific to the reader's project. They can be POJO. They can be listening on a socket, writing to disk, or whatever your project requires.&nbsp;<span style="line-height: 1.5;">For the rest, the JDK offers the necessary building blocks:</span></p>
<ul>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ThreadPoolExecutor.html">ThreadPoolExecutor</a>&nbsp;executes the tasks concurrently, in a dedicated pool of threads.</li>
<li><a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorCompletionService.html">ExecutorCompletionService</a>&nbsp;retrieves the Tasks from the TaskQueue and feed them to the ThreadPoolExecutor.</li>
<li>The short&nbsp;ExecutorCompletionService constructor uses a&nbsp;<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/LinkedBlockingQueue.html">LinkedBlockingQueue</a> as the&nbsp;TaskQueue.</li>
<li>For the Tasks to be handled by ThreadPoolExecutor, Task must implements Callable.</li>
</ul>
<h1>Sample&nbsp;implementation</h1>
<p>To illustrate this design, I've shared <a href="https://github.com/proudier/blog-example/tree/master/ExecutorCompletionService/src/net/pierreroudier/blog">a sample project on GitHub</a>.</p>
<p>Noteworthy items:</p>
<ul>
<li>TaskParameter and TaskResult are POJO with a few attributes.</li>
<li>Task&nbsp;computation of a&nbsp;factorial for the number given in TaskParameter.</li>
<li>TaskProducer creates a new Task periodically and submit it.</li>
<li>TaskConsumer retrieve and display the result.</li>
<li>To present a generic pattern, TaskProducer and ResultConsumer implements Runnable, so they can be executed concurrently as well.</li>
</ul>
<p>Here is the most important piece of code:</p>
<pre class="prettyprint">// in Main.java
ExecutorService es = Executors.newFixedThreadPool(THREAD_COUNT);
ExecutorCompletionService<TaskResult> ecs = new ExecutorCompletionService<TaskResult>(es);</pre>
<p>TaskProducers call&nbsp;ExecutorCompletionService.<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorCompletionService.html#submit-java.util.concurrent.Callable-">submit</a>&nbsp;to push new tasks:</p>
<pre class="prettyprint">// in TaskProducer.java (edited for clarity)
TaskParameter param = new TaskParameter( &hellip; );
Task computation = new Task(param);
ecs.submit(computation);</pre>
<p>ResultConsumer call&nbsp;ExecutorCompletionService.<a href="https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorCompletionService.html#submit-java.util.concurrent.Callable-">take</a>&nbsp;to retrieve the results:</p>
<pre  class="prettyprint">// in ResultConsumer.java (edited for clarity)
Future<TaskResult> future = ecs.take();
future.get()</pre>
<p>Finally, to bootstrap the system:</p>
<pre  class="prettyprint">// in Main.java
new Thread(new TaskProducer(ecs, 2f)).start();
new Thread(new ResultConsumer(ecs)).start();</pre>
<p>The rest of the code is pretty self-explanatory&nbsp;&#x263a;</p>
<p>Enjoy!</p>
<p>&nbsp;</p>
